{"name":"dry-validation","tagline":"Data validation library based on predicate logic and rule composition","body":"[gem]: https://rubygems.org/gems/dry-validation\r\n[travis]: https://travis-ci.org/dryrb/dry-validation\r\n[gemnasium]: https://gemnasium.com/dryrb/dry-validation\r\n[codeclimate]: https://codeclimate.com/github/dryrb/dry-validation\r\n[coveralls]: https://coveralls.io/r/dryrb/dry-validation\r\n[inchpages]: http://inch-ci.org/github/dryrb/dry-validation\r\n\r\n# dry-validation [![Join the chat at https://gitter.im/dryrb/chat](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/dryrb/chat)\r\n\r\n[![Gem Version](https://badge.fury.io/rb/dry-validation.svg)][gem]\r\n[![Build Status](https://travis-ci.org/dryrb/dry-validation.svg?branch=master)][travis]\r\n[![Dependency Status](https://gemnasium.com/dryrb/dry-validation.svg)][gemnasium]\r\n[![Code Climate](https://codeclimate.com/github/dryrb/dry-validation/badges/gpa.svg)][codeclimate]\r\n[![Test Coverage](https://codeclimate.com/github/dryrb/dry-validation/badges/coverage.svg)][codeclimate]\r\n[![Inline docs](http://inch-ci.org/github/dryrb/dry-validation.svg?branch=master)][inchpages]\r\n\r\nData validation library based on predicate logic and rule composition.\r\n\r\n## Overview\r\n\r\nUnlike other, well known, validation solutions in Ruby, `dry-validation` takes\r\na different approach and focuses a lot on explicitness, clarity and preciseness\r\nof validation logic. It is designed to work with any data input, whether it's a\r\nsimple hash, an array or a complex object with deeply nested data.\r\n\r\nIt is based on a simple idea that each validation is encapsulated by a simple,\r\nstateless predicate, that receives some input and returns either `true` or `false`.\r\n\r\nThose predicates are encapsulated by `rules` which can be composed together using\r\n`predicate logic`. This means you can use the common logic operators to build up\r\na validation `schema`.\r\n\r\nIt's very explicit, powerful and extendible.\r\n\r\nValidations can be described with great precision, `dry-validation` eliminates\r\nambigious concepts like `presence` validation where we can't really say whether\r\nsome attribute or key is *missing* or it's just that the value is `nil`.\r\n\r\nThere's also the concept of type-safety, completely missing in other validation\r\nlibraries, which is quite important and useful. It means you can compose a validation\r\nthat does rely on the type of a given value. In example it makes no sense to validate\r\neach element of an array when it turns out to be an empty string.\r\n\r\n## The DSL\r\n\r\nThe core of `dry-validation` is rules composition and predicate logic. The DSL\r\nis a simple front-end for that. It only allows you to define the rules by using\r\npredicate identifiers. There are no magical options, conditionals and custom\r\nvalidation blocks known from other libraries. The focus is on pure validation\r\nlogic.\r\n\r\n## Examples\r\n\r\n### Basic\r\n\r\nHere's a basic example where we validate following things:\r\n\r\n* The input *must have a key* called `:email`\r\n  * Provided the email key is present, its value *must be filled*\r\n* The input *must have a key* called `:age`\r\n  * Provided the age key is present, its value *must be an integer* and it *must be greater than 18*\r\n\r\nThis can be easily expressed through the DSL:\r\n\r\n``` ruby\r\nrequire 'dry-validation'\r\n\r\nclass Schema < Dry::Validation::Schema\r\n  key(:email) { |email| email.filled? }\r\n\r\n  key(:age) do |age|\r\n    age.int? & age.gt?(18)\r\n  end\r\nend\r\n\r\nschema = Schema.new\r\n\r\nerrors = schema.messages(email: 'jane@doe.org', age: 19)\r\n\r\nputs errors.inspect\r\n# []\r\n\r\nerrors = schema.messages(email: nil, age: 19)\r\n\r\nputs errors.inspect\r\n# [[:email, [\"email must be filled\"]]]\r\n```\r\n\r\nA couple of remarks:\r\n\r\n* `key` assumes that we want to use the `:key?` predicate to check the existance of that key\r\n* `age.gt?(18)` translates to calling a predicate like this: `schema[:gt?].(18, age)`\r\n* `age.int? & age.gt?(18)` is a conjunction, so we don't bother about `gt?` unless `int?` returns `true`\r\n* You can also use `|` for disjunction\r\n* Schema object does not carry the input as its state, nor does it know how to access the input values, we\r\n  pass the input to `call` and get error set as the response\r\n\r\n### Optional Keys\r\n\r\nYou can define which keys are optional and define rules for their values:\r\n\r\n``` ruby\r\nrequire 'dry-validation'\r\n\r\nclass Schema < Dry::Validation::Schema\r\n  key(:email) { |email| email.filled? }\r\n\r\n  optional(:age) do |age|\r\n    age.int? & age.gt?(18)\r\n  end\r\nend\r\n\r\nschema = Schema.new\r\n\r\nerrors = schema.messages(email: 'jane@doe.org')\r\n\r\nputs errors.inspect\r\n# []\r\n\r\nerrors = schema.messages(email: 'jane@doe.org', age: 17)\r\n\r\nputs errors.inspect\r\n# [[:age, [\"age must be greater than 18 (17 was given)\"]]]\r\n```\r\n\r\n### Optional Values\r\n\r\nWhen it is valid for a given value to be `nil` you can use `none?` predicate:\r\n\r\n``` ruby\r\nrequire 'dry-validation'\r\n\r\nclass Schema < Dry::Validation::Schema\r\n  key(:email) { |email| email.filled? }\r\n\r\n  key(:age) do |age|\r\n    age.none? | (age.int? & age.gt?(18))\r\n  end\r\nend\r\n\r\nschema = Schema.new\r\n\r\nerrors = schema.messages(email: 'jane@doe.org', age: nil)\r\n\r\nputs errors.inspect\r\n# []\r\n\r\nerrors = schema.messages(email: 'jane@doe.org', age: 19)\r\n\r\nputs errors.inspect\r\n# []\r\n\r\nerrors = schema.messages(email: 'jane@doe.org', age: 17)\r\n\r\nputs errors.inspect\r\n# [[:age, [\"age must be greater than 18 (17 was given)\"]]]\r\n```\r\n\r\n### Optional Key vs Value\r\n\r\nWe make a clear distinction between specifying an optional `key` and an optional\r\n`value`. This gives you a way of being very specific about validation rules. You\r\ncan define a schema which can give you precise errors when a key was missing or\r\nkey was present but the value was nil.\r\n\r\nThis also comes with the benefit of being explicit about the type expectation.\r\nIn the example above we explicitly state that `:age` *can be nil* or it *can be an integer*\r\nand when it *is an integer* we specify that it *must be greater than 18*.\r\n\r\nAnother benefit is that we can infer specific coercion rules when types are specified.\r\nIn example [`Schema::Form`](https://github.com/dryrb/dry-validation#form-validation-with-coercions)\r\nwill use `form.nil` type from dry-data to coerce empty strings into `nil` for you\r\nwhenever you specify `value.none? | value.int?`. Furthermore it will try to coerce\r\nto `int` since that is our type expectation.\r\n\r\n### Nested Hash\r\n\r\nWe are free to define validations for anything, including deeply nested structures:\r\n\r\n``` ruby\r\nrequire 'dry-validation'\r\n\r\nclass Schema < Dry::Validation::Schema\r\n  key(:address) do |address|\r\n    address.hash? do\r\n      address.key(:city) do |city|\r\n        city.min_size?(3)\r\n      end\r\n\r\n      address.key(:street) do |street|\r\n        street.filled?\r\n      end\r\n\r\n      address.key(:country) do |country|\r\n        country.key(:name, &:filled?)\r\n        country.key(:code, &:filled?)\r\n      end\r\n    end\r\n  end\r\nend\r\n\r\nschema = Schema.new\r\n\r\nerrors = schema.messages({})\r\n\r\nputs errors.inspect\r\n# [[:address, [\"address is missing\"]]]\r\n\r\nerrors = schema.messages(address: { city: 'NYC' })\r\n\r\nputs errors.inspect\r\n# [[:address, [[:street, [\"street is missing\"]], [:country, [\"country is missing\"]]]]]\r\n```\r\n\r\n### Array Elements\r\n\r\nYou can use `each` rule for validating each element in an array:\r\n\r\n``` ruby\r\nclass Schema < Dry::Validation::Schema\r\n  key(:phone_numbers) do |phone_numbers|\r\n    phone_numbers.array? do\r\n      phone_numbers.each(&:str?)\r\n    end\r\n  end\r\nend\r\n\r\nschema = Schema.new\r\n\r\nerrors = schema.messages(phone_numbers: '')\r\n\r\nputs errors.inspect\r\n# [[:phone_numbers, [\"phone_numbers must be an array\"]]]\r\n\r\nerrors = schema.messages(phone_numbers: ['123456789', 123456789])\r\n\r\nputs errors.inspect\r\n# [[:phone_numbers, [[:phone_numbers, [\"phone_numbers must be a string\"]]]]]\r\n```\r\n\r\n### Form Validation With Coercions\r\n\r\nProbably the most common use case is to validate form params. This is a special\r\nkind of a validation for a couple of reasons:\r\n\r\n* The input is a hash with stringified keys\r\n* The input include values that are strings, hashes or arrays\r\n* Prior validation, we need to coerce values and symbolize keys based on the\r\n  information from rules\r\n\r\nFor that reason, `dry-validation` ships with `Schema::Form` class:\r\n\r\n``` ruby\r\nrequire 'dry-validation'\r\nrequire 'dry/validation/schema/form'\r\n\r\nclass UserFormSchema < Dry::Validation::Schema::Form\r\n  key(:email) { |value| value.str? & value.filled? }\r\n\r\n  key(:age) { |value| value.int? & value.gt?(18) }\r\nend\r\n\r\nschema = UserFormSchema.new\r\n\r\nerrors = schema.messages('email' => '', 'age' => '18')\r\n\r\nputs errors.inspect\r\n\r\n# [[:email, [\"email must be filled\"]], [:age, [\"age must be greater than 18 (18 was given)\"]]]\r\n```\r\n\r\nThere are few major differences between how it works here and in `ActiveModel`:\r\n\r\n* We have type checking as predicates, ie `gt?(18)` will not be applied if the value\r\n  is not an integer\r\n* Thus, error messages are provided *only for the rules that failed*\r\n* There's a planned feature for generating \"validation hints\" which lists information\r\n  about all possible rules\r\n* Coercion is handled by `dry-data` coercible hash using its `form.*` types that\r\n  are dedicated for this type of coercions\r\n* It's very easy to add your own types and coercions (more info/docs coming soon)\r\n\r\n### Defining Custom Predicates\r\n\r\nYou can simply define predicate methods on your schema object:\r\n\r\n``` ruby\r\nclass Schema < Dry::Validation::Schema\r\n  key(:email) { |value| value.str? & value.email? }\r\n\r\n  def email?(value)\r\n    ! /magical-regex-that-matches-emails/.match(value).nil?\r\n  end\r\nend\r\n```\r\n\r\nYou can also re-use a predicate container across multiple schemas:\r\n\r\n``` ruby\r\nmodule MyPredicates\r\n  include Dry::Validation::Predicates\r\n\r\n  predicate(:email?) do |input|\r\n    ! /magical-regex-that-matches-emails/.match(value).nil?\r\n  end\r\nend\r\n\r\nclass Schema < Dry::Validation::Schema\r\n  configure do |config|\r\n    config.predicates = MyPredicates\r\n  end\r\n\r\n  key(:email) { |value| value.str? & value.email? }\r\nend\r\n```\r\n\r\nYou need to provide error messages for your custom predicates if you want them\r\nto work with `Schem#messages` interface.\r\n\r\nYou can learn how to do that in the [Error Messages](https://github.com/dryrb/dry-validation#error-messages) section.\r\n\r\n## List of Built-In Predicates\r\n\r\n### Basic\r\n\r\n* `none?`\r\n* `eql?`\r\n* `key?`\r\n\r\n### Types\r\n\r\n* `str?`\r\n* `int?`\r\n* `float?`\r\n* `decimal?`\r\n* `bool?`\r\n* `date?`\r\n* `date_time?`\r\n* `time?`\r\n* `array?`\r\n* `hash?`\r\n\r\n### Number, String, Collection\r\n\r\n* `empty?`\r\n* `filled?`\r\n* `gt?`\r\n* `gteq?`\r\n* `lt?`\r\n* `lteq?`\r\n* `max_size?`\r\n* `min_size?`\r\n* `size?`\r\n* `format?`\r\n* `inclusion?`\r\n* `exclusion?`\r\n\r\n## Error Messages\r\n\r\nBy default `dry-validation` comes with a set of pre-defined error messages for\r\nevery built-in predicate. They are defined in [a yaml file](https://github.com/dryrb/dry-validation/blob/master/config/errors.yml)\r\nwhich is shipped with the gem.\r\n\r\nYou can provide your own messages and configure your schemas to use it like that:\r\n\r\n``` ruby\r\nclass Schema < Dry::Validation::Schema\r\n  configure { |config| config.messages_file = '/path/to/my/errors.yml' }\r\nend\r\n```\r\n\r\nYou can also provide a namespace per-schema that will be used by default:\r\n\r\n``` ruby\r\nclass Schema < Dry::Validation::Schema\r\n  configure { |config| config.namespace = :user }\r\nend\r\n```\r\n\r\nLookup rules:\r\n\r\n``` yaml\r\nfilled?: \"%{name} must be filled\"\r\n\r\nattributes:\r\n  email:\r\n    filled?: \"the email is missing\"\r\n\r\nuser:\r\n  filled?: \"%{name} name cannot be blank\"\r\n\r\n  attributes:\r\n    address:\r\n      filled?: \"You gotta tell us where you live\"\r\n```\r\n\r\nGiven the yaml file above, messages lookup works as follows:\r\n\r\n``` ruby\r\nmessages = Dry::Validation::Messages.load('/path/to/our/errors.yml')\r\n\r\nmessages.lookup(:filled?, :age) # => \"age must be filled\"\r\nmessages.lookup(:filled?, :address) # => \"address must be filled\"\r\nmessages.lookup(:filled?, :email) # => \"the email is missing\"\r\n\r\n# with namespaced messages\r\nuser_messages = messages.namespaced(:user)\r\n\r\nuser_messages.lookup(:filled?, :age) # \"age cannot be blank\"\r\nuser_messages.lookup(:filled?, :address) # \"You gotta tell us where you live\"\r\n```\r\n\r\nBy configuring `messages_file` and/or `namespace` in a schema, default messages\r\nare going to be automatically merged with your overrides and/or namespaced.\r\n\r\n## I18n Integration\r\n\r\nComing (very) soon...\r\n\r\n## Rule AST\r\n\r\nInternally, `dry-validation` uses a simple AST representation of rules and errors\r\nto produce rule objects and error messages. If you would like to programatically\r\ngenerate rules, it is a very simple process:\r\n\r\n``` ruby\r\nast = [\r\n  [\r\n    :and,\r\n    [\r\n      [:key, [:age, [:predicate, [:key?, []]]]],\r\n      [\r\n        :and,\r\n        [\r\n          [:val, [:age, [:predicate, [:filled?, []]]]],\r\n          [:val, [:age, [:predicate, [:gt?, [18]]]]]\r\n        ]\r\n      ]\r\n    ]\r\n  ]\r\n]\r\n\r\ncompiler = Dry::Validation::RuleCompiler.new(Dry::Validation::Predicates)\r\n\r\n# compile an array of rule objects\r\nrules = compiler.call(ast)\r\n\r\nputs rules.inspect\r\n# [\r\n#   #<Dry::Validation::Rule::Conjunction\r\n#     left=#<Dry::Validation::Rule::Key name=:age predicate=#<Dry::Validation::Predicate id=:key?>>\r\n#     right=#<Dry::Validation::Rule::Conjunction\r\n#       left=#<Dry::Validation::Rule::Value name=:age predicate=#<Dry::Validation::Predicate id=:filled?>>\r\n#       right=#<Dry::Validation::Rule::Value name=:age predicate=#<Dry::Validation::Predicate id=:gt?>>>>\r\n# ]\r\n\r\n# dump it back to ast\r\nputs rules.map(&:to_ary).inspect\r\n# [[:and, [:key, [:age, [:predicate, [:key?, [:age]]]]], [[:and, [:val, [:age, [:predicate, [:filled?, []]]]], [[:val, [:age, [:predicate, [:gt?, [18]]]]]]]]]]\r\n```\r\n\r\nComplete docs for the AST format are coming soon, for now please refer to\r\n[this spec](https://github.com/dryrb/dry-validation/blob/master/spec/unit/rule_compiler_spec.rb).\r\n\r\n## Status and Roadmap\r\n\r\nThis library is in a very early stage of development but you are encauraged to\r\ntry it out and provide feedback.\r\n\r\nFor planned features check out [the issues](https://github.com/dryrb/dry-validation/labels/feature).\r\n\r\n## License\r\n\r\nSee `LICENSE` file.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}