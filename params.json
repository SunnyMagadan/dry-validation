{"name":"dry-validation","tagline":"Data validation library based on predicate logic and rule composition","body":"[gem]: https://rubygems.org/gems/dry-validation\r\n[travis]: https://travis-ci.org/dryrb/dry-validation\r\n[gemnasium]: https://gemnasium.com/dryrb/dry-validation\r\n[codeclimate]: https://codeclimate.com/github/dryrb/dry-validation\r\n[coveralls]: https://coveralls.io/r/dryrb/dry-validation\r\n[inchpages]: http://inch-ci.org/github/dryrb/dry-validation\r\n\r\n# dry-validation [![Join the chat at https://gitter.im/dryrb/chat](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/dryrb/chat)\r\n\r\n[![Gem Version](https://badge.fury.io/rb/dry-validation.svg)][gem]\r\n[![Build Status](https://travis-ci.org/dryrb/dry-validation.svg?branch=master)][travis]\r\n[![Dependency Status](https://gemnasium.com/dryrb/dry-validation.svg)][gemnasium]\r\n[![Code Climate](https://codeclimate.com/github/dryrb/dry-validation/badges/gpa.svg)][codeclimate]\r\n[![Test Coverage](https://codeclimate.com/github/dryrb/dry-validation/badges/coverage.svg)][codeclimate]\r\n[![Inline docs](http://inch-ci.org/github/dryrb/dry-validation.svg?branch=master)][inchpages]\r\n\r\nData validation library based on predicate logic and rule composition.\r\n\r\n## Overview\r\n\r\nUnlike other, well known, validation solutions in Ruby, `dry-validation` takes\r\na different approach and focuses a lot on explicitness, clarity and preciseness\r\nof validation logic. It is designed to work with any data input, whether it's a\r\nsimple hash, an array or a complex object with deeply nested data.\r\n\r\nIt is based on a simple idea that each validation is encapsulated by a simple,\r\nstateless predicate, that receives some input and returns either `true` or `false`.\r\n\r\nThose predicates are encapsulated by `rules` which can be composed together using\r\n`predicate logic`. This means you can use the common logic operators to build up\r\na validation `schema`.\r\n\r\nIt's very explicit, powerful and extendible.\r\n\r\nValidations can be described with great precision, `dry-validation` eliminates\r\nambigious concepts like `presence` validation where we can't really say whether\r\nsome attribute or key is *missing* or it's just that the value is `nil`.\r\n\r\nThere's also the concept of type-safety, completely missing in other validation\r\nlibraries, which is quite important and useful. It means you can compose a validation\r\nthat does rely on the type of a given value. In example it makes no sense to validate\r\neach element of an array when it turns out to be an empty string.\r\n\r\n## The DSL\r\n\r\nThe core of `dry-validation` is rules composition and predicate logic. The DSL\r\nis a simple front-end for that. It only allows you to define the rules by using\r\npredicate identifiers. There are no magical options, conditionals and custom\r\nvalidation blocks known from other libraries. The focus is on pure validation\r\nlogic.\r\n\r\n## Examples\r\n\r\n### Basic\r\n\r\nHere's a basic example where we validate following things:\r\n\r\n* The input *must have a key* called `:email`\r\n  * Provided the email key is present, its value *must be filled*\r\n* The input *must have a key* called `:age`\r\n  * Provided the age key is present, its value *must be an integer* and it *must be greater than 18*\r\n\r\nThis can be easily expressed through the DSL:\r\n\r\n``` ruby\r\nrequire 'dry-validation'\r\n\r\nclass Schema < Dry::Validation::Schema\r\n  key(:email) { |email| email.filled? }\r\n\r\n  key(:age) do |age|\r\n    age.int? & age.gt?(18)\r\n  end\r\nend\r\n\r\nschema = Schema.new\r\n\r\nerrors = schema.messages(email: 'jane@doe.org', age: 19)\r\n\r\nputs errors.inspect\r\n# []\r\n\r\nerrors = schema.messages(email: nil, age: 19)\r\n\r\nputs errors.inspect\r\n# [[:email, [\"email must be filled\"]]]\r\n```\r\n\r\nA couple of remarks:\r\n\r\n* `key` assumes that we want to use the `:key?` predicate to check the existance of that key\r\n* `age.gt?(18)` translates to calling a predicate like this: `schema[:gt?].(18, age)`\r\n* `age.int? & age.gt?(18)` is a conjunction, so we don't bother about `gt?` unless `int?` returns `true`\r\n* You can also use `|` for disjunction\r\n* Schema object does not carry the input as its state, nor does it know how to access the input values, we\r\n  pass the input to `call` and get error set as the response\r\n\r\n### Nested Hash\r\n\r\nWe are free to define validations for anything, including deeply nested structures:\r\n\r\n``` ruby\r\nrequire 'dry-validation'\r\n\r\nclass Schema < Dry::Validation::Schema\r\n  key(:address) do |address|\r\n    address.key(:city) do |city|\r\n      city.min_size?(3)\r\n    end\r\n\r\n    address.key(:street) do |street|\r\n      street.filled?\r\n    end\r\n\r\n    address.key(:country) do |country|\r\n      country.key(:name, &:filled?)\r\n      country.key(:code, &:filled?)\r\n    end\r\n  end\r\nend\r\n\r\nschema = Schema.new\r\n\r\nerrors = schema.messages({})\r\n\r\nputs errors.inspect\r\n# [[:address, [\"address is missing\"]]]\r\n\r\nerrors = schema.messages(address: { city: 'NYC' })\r\n\r\nputs errors.inspect\r\n# [[:address, [[:street, [\"street is missing\"]], [:country, [\"country is missing\"]]]]]\r\n```\r\n\r\n### Defining Custom Predicates\r\n\r\nYou can simply define predicate methods on your schema object:\r\n\r\n``` ruby\r\nclass Schema < Dry::Validation::Schema\r\n  key(:email) { |value| value.str? & value.email? }\r\n\r\n  def email?(value)\r\n    ! /magical-regex-that-matches-emails/.match(value).nil?\r\n  end\r\nend\r\n```\r\n\r\nYou can also re-use a predicate container across multiple schemas:\r\n\r\n``` ruby\r\nmodule MyPredicates\r\n  include Dry::Validation::Predicates\r\n\r\n  predicate(:email?) do |input|\r\n    ! /magical-regex-that-matches-emails/.match(value).nil?\r\n  end\r\nend\r\n\r\nclass Schema < Dry::Validation::Schema\r\n  configure do |config|\r\n    config.predicates = MyPredicates\r\n  end\r\n\r\n  key(:email) { |value| value.str? & value.email? }\r\nend\r\n```\r\n\r\n## List of Built-In Predicates\r\n\r\n* `empty?`\r\n* `eql?`\r\n* `exclusion?`\r\n* `filled?`\r\n* `format?`\r\n* `gt?`\r\n* `gteq?`\r\n* `inclusion?`\r\n* `int?`\r\n* `key?`\r\n* `lt?`\r\n* `lteq?`\r\n* `max_size?`\r\n* `min_size?`\r\n* `nil?`\r\n* `size?`\r\n* `str?`\r\n\r\n## Error Messages\r\n\r\nBy default `dry-validation` comes with a set of pre-defined error messages for\r\nevery built-in predicate. They are defined in [a yaml file](https://github.com/dryrb/dry-validation/blob/master/config/errors.yml)\r\nwhich is shipped with the gem.\r\n\r\nYou can provide your own messages and configure your schemas to use it like that:\r\n\r\n``` ruby\r\nclass Schema < Dry::Validation::Schema\r\n  configure { |config| config.messages_file = '/path/to/my/errors.yml' }\r\nend\r\n```\r\n\r\nYou can also provide a namespace per-schema that will be used by default:\r\n\r\n``` ruby\r\nclass Schema < Dry::Validation::Schema\r\n  configure { |config| config.namespace = :user }\r\nend\r\n```\r\n\r\nLookup rules:\r\n\r\n``` yaml\r\nfilled?: \"%{name} must be filled\"\r\n\r\nattributes:\r\n  email:\r\n    filled?: \"the email is missing\"\r\n\r\nuser:\r\n  filled?: \"%{name} name cannot be blank\"\r\n\r\n  attributes:\r\n    address:\r\n      filled?: \"You gotta tell us where you live\"\r\n```\r\n\r\nGiven the yaml file above, messages lookup works as follows:\r\n\r\n``` ruby\r\nmessages = Dry::Validation::Messages.load('/path/to/our/errors.yml')\r\n\r\nmessages.lookup(:filled?, :age) # => \"age must be filled\"\r\nmessages.lookup(:filled?, :address) # => \"address must be filled\"\r\nmessages.lookup(:filled?, :email) # => \"the email is missing\"\r\n\r\n# with namespaced messages\r\nuser_messages = messages.namespaced(:user)\r\n\r\nuser_messages.lookup(:filled?, :age) # \"age cannot be blank\"\r\nuser_messages.lookup(:filled?, :address) # \"You gotta tell us where you live\"\r\n```\r\n\r\nBy configuring `messages_file` and/or `namespace` in a schema, default messages\r\nare going to be automatically merged with your overrides and/or namespaced.\r\n\r\n## I18n Integration\r\n\r\nComing (very) soon...\r\n\r\n## Rule AST\r\n\r\nInternally, `dry-validation` uses a simple AST representation of rules and errors\r\nto produce rule objects and error messages. If you would like to programatically\r\ngenerate rules, it is a very simple process:\r\n\r\n``` ruby\r\nast = [\r\n  [\r\n    :and,\r\n    [\r\n      [:key, [:age, [:predicate, [:key?, []]]]],\r\n      [\r\n        :and,\r\n        [\r\n          [:val, [:age, [:predicate, [:filled?, []]]]],\r\n          [:val, [:age, [:predicate, [:gt?, [18]]]]]\r\n        ]\r\n      ]\r\n    ]\r\n  ]\r\n]\r\n\r\ncompiler = Dry::Validation::RuleCompiler.new(Dry::Validation::Predicates)\r\n\r\n# compile an array of rule objects\r\nrules = compiler.call(ast)\r\n\r\nputs rules.inspect\r\n# [\r\n#   #<Dry::Validation::Rule::Conjunction\r\n#     left=#<Dry::Validation::Rule::Key name=:age predicate=#<Dry::Validation::Predicate id=:key?>>\r\n#     right=#<Dry::Validation::Rule::Conjunction\r\n#       left=#<Dry::Validation::Rule::Value name=:age predicate=#<Dry::Validation::Predicate id=:filled?>>\r\n#       right=#<Dry::Validation::Rule::Value name=:age predicate=#<Dry::Validation::Predicate id=:gt?>>>>\r\n# ]\r\n\r\n# dump it back to ast\r\nputs rules.map(&:to_ary).inspect\r\n# [[:and, [:key, [:age, [:predicate, [:key?, [:age]]]]], [[:and, [:val, [:age, [:predicate, [:filled?, []]]]], [[:val, [:age, [:predicate, [:gt?, [18]]]]]]]]]]\r\n```\r\n\r\nComplete docs for the AST format are coming soon, for now please refer to\r\n[this spec](https://github.com/dryrb/dry-validation/blob/master/spec/unit/rule_compiler_spec.rb).\r\n\r\n## Status and Roadmap\r\n\r\nThis library is in a very early stage of development but you are encauraged to\r\ntry it out and provide feedback.\r\n\r\nFor planned features check out [the issues](https://github.com/dryrb/dry-validation/labels/feature).\r\n\r\n## License\r\n\r\nSee `LICENSE` file.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}