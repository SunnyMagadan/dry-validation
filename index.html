<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>dry-validation by dryrb</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">dry-validation</h1>
      <h2 class="project-tagline">Data validation library based on predicate logic and rule composition</h2>
      <a href="https://github.com/dryrb/dry-validation" class="btn">View on GitHub</a>
      <a href="https://github.com/dryrb/dry-validation/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/dryrb/dry-validation/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h1>
<a id="dry-validation-" class="anchor" href="#dry-validation-" aria-hidden="true"><span class="octicon octicon-link"></span></a>dry-validation <a href="https://gitter.im/dryrb/chat"><img src="https://badges.gitter.im/Join%20Chat.svg" alt="Join the chat at https://gitter.im/dryrb/chat"></a>
</h1>

<p><a href="https://rubygems.org/gems/dry-validation"><img src="https://badge.fury.io/rb/dry-validation.svg" alt="Gem Version"></a>
<a href="https://travis-ci.org/dryrb/dry-validation"><img src="https://travis-ci.org/dryrb/dry-validation.svg?branch=master" alt="Build Status"></a>
<a href="https://gemnasium.com/dryrb/dry-validation"><img src="https://gemnasium.com/dryrb/dry-validation.svg" alt="Dependency Status"></a>
<a href="https://codeclimate.com/github/dryrb/dry-validation"><img src="https://codeclimate.com/github/dryrb/dry-validation/badges/gpa.svg" alt="Code Climate"></a>
<a href="https://codeclimate.com/github/dryrb/dry-validation"><img src="https://codeclimate.com/github/dryrb/dry-validation/badges/coverage.svg" alt="Test Coverage"></a>
<a href="http://inch-ci.org/github/dryrb/dry-validation"><img src="http://inch-ci.org/github/dryrb/dry-validation.svg?branch=master" alt="Inline docs"></a></p>

<p>Data validation library based on predicate logic and rule composition.</p>

<h2>
<a id="overview" class="anchor" href="#overview" aria-hidden="true"><span class="octicon octicon-link"></span></a>Overview</h2>

<p>Unlike other, well known, validation solutions in Ruby, <code>dry-validation</code> takes
a different approach and focuses a lot on explicitness, clarity and preciseness
of validation logic. It is designed to work with any data input, whether it's a
simple hash, an array or a complex object with deeply nested data.</p>

<p>It is based on a simple idea that each validation is encapsulated by a simple,
stateless predicate, that receives some input and returns either <code>true</code> or <code>false</code>.</p>

<p>Those predicates are encapsulated by <code>rules</code> which can be composed together using
<code>predicate logic</code>. This means you can use the common logic operators to build up
a validation <code>schema</code>.</p>

<p>It's very explicit, powerful and extendible.</p>

<p>Validations can be described with great precision, <code>dry-validation</code> eliminates
ambigious concepts like <code>presence</code> validation where we can't really say whether
some attribute or key is <em>missing</em> or it's just that the value is <code>nil</code>.</p>

<p>There's also the concept of type-safety, completely missing in other validation
libraries, which is quite important and useful. It means you can compose a validation
that does rely on the type of a given value. In example it makes no sense to validate
each element of an array when it turns out to be an empty string.</p>

<h2>
<a id="the-dsl" class="anchor" href="#the-dsl" aria-hidden="true"><span class="octicon octicon-link"></span></a>The DSL</h2>

<p>The core of <code>dry-validation</code> is rules composition and predicate logic. The DSL
is a simple front-end for that. It only allows you to define the rules by using
predicate identifiers. There are no magical options, conditionals and custom
validation blocks known from other libraries. The focus is on pure validation
logic.</p>

<h2>
<a id="examples" class="anchor" href="#examples" aria-hidden="true"><span class="octicon octicon-link"></span></a>Examples</h2>

<h3>
<a id="basic" class="anchor" href="#basic" aria-hidden="true"><span class="octicon octicon-link"></span></a>Basic</h3>

<p>Here's a basic example where we validate following things:</p>

<ul>
<li>The input <em>must have a key</em> called <code>:email</code>

<ul>
<li>Provided the email key is present, its value <em>must be filled</em>
</li>
</ul>
</li>
<li>The input <em>must have a key</em> called <code>:age</code>

<ul>
<li>Provided the age key is present, its value <em>must be an integer</em> and it <em>must be greater than 18</em>
</li>
</ul>
</li>
</ul>

<p>This can be easily expressed through the DSL:</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-k">require</span> <span class="pl-s"><span class="pl-pds">'</span>dry-validation<span class="pl-pds">'</span></span>

<span class="pl-k">class</span> <span class="pl-en">Schema<span class="pl-e"> &lt; Dry::Validation::Schema</span></span>
  key(<span class="pl-c1">:email</span>) { |<span class="pl-smi">email</span>| email.filled? }

  key(<span class="pl-c1">:age</span>) <span class="pl-k">do </span>|<span class="pl-smi">age</span>|
    age.int? <span class="pl-k">&amp;</span> age.gt?(<span class="pl-c1">18</span>)
  <span class="pl-k">end</span>
<span class="pl-k">end</span>

schema <span class="pl-k">=</span> <span class="pl-c1">Schema</span>.<span class="pl-k">new</span>

errors <span class="pl-k">=</span> schema.messages(<span class="pl-c1">email:</span> <span class="pl-s"><span class="pl-pds">'</span>jane@doe.org<span class="pl-pds">'</span></span>, <span class="pl-c1">age:</span> <span class="pl-c1">19</span>)

puts errors.inspect
<span class="pl-c"># []</span>

errors <span class="pl-k">=</span> schema.messages(<span class="pl-c1">email:</span> <span class="pl-c1">nil</span>, <span class="pl-c1">age:</span> <span class="pl-c1">19</span>)

puts errors.inspect
<span class="pl-c"># [[:email, ["email must be filled"]]]</span></pre></div>

<p>A couple of remarks:</p>

<ul>
<li>
<code>key</code> assumes that we want to use the <code>:key?</code> predicate to check the existance of that key</li>
<li>
<code>age.gt?(18)</code> translates to calling a predicate like this: <code>schema[:gt?].(18, age)</code>
</li>
<li>
<code>age.int? &amp; age.gt?(18)</code> is a conjunction, so we don't bother about <code>gt?</code> unless <code>int?</code> returns <code>true</code>
</li>
<li>You can also use <code>|</code> for disjunction</li>
<li>Schema object does not carry the input as its state, nor does it know how to access the input values, we
pass the input to <code>call</code> and get error set as the response</li>
</ul>

<h3>
<a id="optional-keys" class="anchor" href="#optional-keys" aria-hidden="true"><span class="octicon octicon-link"></span></a>Optional Keys</h3>

<p>You can define which keys are optional and define rules for their values:</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-k">require</span> <span class="pl-s"><span class="pl-pds">'</span>dry-validation<span class="pl-pds">'</span></span>

<span class="pl-k">class</span> <span class="pl-en">Schema<span class="pl-e"> &lt; Dry::Validation::Schema</span></span>
  key(<span class="pl-c1">:email</span>) { |<span class="pl-smi">email</span>| email.filled? }

  optional(<span class="pl-c1">:age</span>) <span class="pl-k">do </span>|<span class="pl-smi">age</span>|
    age.int? <span class="pl-k">&amp;</span> age.gt?(<span class="pl-c1">18</span>)
  <span class="pl-k">end</span>
<span class="pl-k">end</span>

schema <span class="pl-k">=</span> <span class="pl-c1">Schema</span>.<span class="pl-k">new</span>

errors <span class="pl-k">=</span> schema.messages(<span class="pl-c1">email:</span> <span class="pl-s"><span class="pl-pds">'</span>jane@doe.org<span class="pl-pds">'</span></span>)

puts errors.inspect
<span class="pl-c"># []</span>

errors <span class="pl-k">=</span> schema.messages(<span class="pl-c1">email:</span> <span class="pl-s"><span class="pl-pds">'</span>jane@doe.org<span class="pl-pds">'</span></span>, <span class="pl-c1">age:</span> <span class="pl-c1">17</span>)

puts errors.inspect
<span class="pl-c"># [[:age, ["age must be greater than 18 (17 was given)"]]]</span></pre></div>

<h3>
<a id="optional-values" class="anchor" href="#optional-values" aria-hidden="true"><span class="octicon octicon-link"></span></a>Optional Values</h3>

<p>When it is valid for a given value to be <code>nil</code> you can use <code>none?</code> predicate:</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-k">require</span> <span class="pl-s"><span class="pl-pds">'</span>dry-validation<span class="pl-pds">'</span></span>

<span class="pl-k">class</span> <span class="pl-en">Schema<span class="pl-e"> &lt; Dry::Validation::Schema</span></span>
  key(<span class="pl-c1">:email</span>) { |<span class="pl-smi">email</span>| email.filled? }

  key(<span class="pl-c1">:age</span>) <span class="pl-k">do </span>|<span class="pl-smi">age</span>|
    age.none? <span class="pl-k">|</span> (age.int? <span class="pl-k">&amp;</span> age.gt?(<span class="pl-c1">18</span>))
  <span class="pl-k">end</span>
<span class="pl-k">end</span>

schema <span class="pl-k">=</span> <span class="pl-c1">Schema</span>.<span class="pl-k">new</span>

errors <span class="pl-k">=</span> schema.messages(<span class="pl-c1">email:</span> <span class="pl-s"><span class="pl-pds">'</span>jane@doe.org<span class="pl-pds">'</span></span>, <span class="pl-c1">age:</span> <span class="pl-c1">nil</span>)

puts errors.inspect
<span class="pl-c"># []</span>

errors <span class="pl-k">=</span> schema.messages(<span class="pl-c1">email:</span> <span class="pl-s"><span class="pl-pds">'</span>jane@doe.org<span class="pl-pds">'</span></span>, <span class="pl-c1">age:</span> <span class="pl-c1">19</span>)

puts errors.inspect
<span class="pl-c"># []</span>

errors <span class="pl-k">=</span> schema.messages(<span class="pl-c1">email:</span> <span class="pl-s"><span class="pl-pds">'</span>jane@doe.org<span class="pl-pds">'</span></span>, <span class="pl-c1">age:</span> <span class="pl-c1">17</span>)

puts errors.inspect
<span class="pl-c"># [[:age, ["age must be greater than 18 (17 was given)"]]]</span></pre></div>

<h3>
<a id="optional-key-vs-value" class="anchor" href="#optional-key-vs-value" aria-hidden="true"><span class="octicon octicon-link"></span></a>Optional Key vs Value</h3>

<p>We make a clear distinction between specifying an optional <code>key</code> and an optional
<code>value</code>. This gives you a way of being very specific about validation rules. You
can define a schema which can give you precise errors when a key was missing or
key was present but the value was nil.</p>

<p>This also comes with the benefit of being explicit about the type expectation.
In the example above we explicitly state that <code>:age</code> <em>can be nil</em> or it <em>can be an integer</em>
and when it <em>is an integer</em> we specify that it <em>must be greater than 18</em>.</p>

<p>Another benefit is that we can infer specific coercion rules when types are specified.
In example <a href="https://github.com/dryrb/dry-validation#form-validation-with-coercions"><code>Schema::Form</code></a>
will use <code>form.nil</code> type from dry-data to coerce empty strings into <code>nil</code> for you
whenever you specify <code>value.none? | value.int?</code>. Furthermore it will try to coerce
to <code>int</code> since that is our type expectation.</p>

<h3>
<a id="nested-hash" class="anchor" href="#nested-hash" aria-hidden="true"><span class="octicon octicon-link"></span></a>Nested Hash</h3>

<p>We are free to define validations for anything, including deeply nested structures:</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-k">require</span> <span class="pl-s"><span class="pl-pds">'</span>dry-validation<span class="pl-pds">'</span></span>

<span class="pl-k">class</span> <span class="pl-en">Schema<span class="pl-e"> &lt; Dry::Validation::Schema</span></span>
  key(<span class="pl-c1">:address</span>) <span class="pl-k">do </span>|<span class="pl-smi">address</span>|
    address.hash? <span class="pl-k">do</span>
      address.key(<span class="pl-c1">:city</span>) <span class="pl-k">do </span>|<span class="pl-smi">city</span>|
        city.min_size?(<span class="pl-c1">3</span>)
      <span class="pl-k">end</span>

      address.key(<span class="pl-c1">:street</span>) <span class="pl-k">do </span>|<span class="pl-smi">street</span>|
        street.filled?
      <span class="pl-k">end</span>

      address.key(<span class="pl-c1">:country</span>) <span class="pl-k">do </span>|<span class="pl-smi">country</span>|
        country.key(<span class="pl-c1">:name</span>, <span class="pl-k">&amp;</span><span class="pl-c1">:filled?</span>)
        country.key(<span class="pl-c1">:code</span>, <span class="pl-k">&amp;</span><span class="pl-c1">:filled?</span>)
      <span class="pl-k">end</span>
    <span class="pl-k">end</span>
  <span class="pl-k">end</span>
<span class="pl-k">end</span>

schema <span class="pl-k">=</span> <span class="pl-c1">Schema</span>.<span class="pl-k">new</span>

errors <span class="pl-k">=</span> schema.messages({})

puts errors.inspect
<span class="pl-c"># [[:address, ["address is missing"]]]</span>

errors <span class="pl-k">=</span> schema.messages(<span class="pl-c1">address:</span> { <span class="pl-c1">city:</span> <span class="pl-s"><span class="pl-pds">'</span>NYC<span class="pl-pds">'</span></span> })

puts errors.inspect
<span class="pl-c"># [[:address, [[:street, ["street is missing"]], [:country, ["country is missing"]]]]]</span></pre></div>

<h3>
<a id="array-elements" class="anchor" href="#array-elements" aria-hidden="true"><span class="octicon octicon-link"></span></a>Array Elements</h3>

<p>You can use <code>each</code> rule for validating each element in an array:</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-k">class</span> <span class="pl-en">Schema<span class="pl-e"> &lt; Dry::Validation::Schema</span></span>
  key(<span class="pl-c1">:phone_numbers</span>) <span class="pl-k">do </span>|<span class="pl-smi">phone_numbers</span>|
    phone_numbers.array? <span class="pl-k">do</span>
      phone_numbers.each(<span class="pl-k">&amp;</span><span class="pl-c1">:str?</span>)
    <span class="pl-k">end</span>
  <span class="pl-k">end</span>
<span class="pl-k">end</span>

schema <span class="pl-k">=</span> <span class="pl-c1">Schema</span>.<span class="pl-k">new</span>

errors <span class="pl-k">=</span> schema.messages(<span class="pl-c1">phone_numbers:</span> <span class="pl-s"><span class="pl-pds">'</span><span class="pl-pds">'</span></span>)

puts errors.inspect
<span class="pl-c"># [[:phone_numbers, ["phone_numbers must be an array"]]]</span>

errors <span class="pl-k">=</span> schema.messages(<span class="pl-c1">phone_numbers:</span> [<span class="pl-s"><span class="pl-pds">'</span>123456789<span class="pl-pds">'</span></span>, <span class="pl-c1">123456789</span>])

puts errors.inspect
<span class="pl-c"># [[:phone_numbers, [[:phone_numbers, ["phone_numbers must be a string"]]]]]</span></pre></div>

<h3>
<a id="form-validation-with-coercions" class="anchor" href="#form-validation-with-coercions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Form Validation With Coercions</h3>

<p>Probably the most common use case is to validate form params. This is a special
kind of a validation for a couple of reasons:</p>

<ul>
<li>The input is a hash with stringified keys</li>
<li>The input include values that are strings, hashes or arrays</li>
<li>Prior validation, we need to coerce values and symbolize keys based on the
information from rules</li>
</ul>

<p>For that reason, <code>dry-validation</code> ships with <code>Schema::Form</code> class:</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-k">require</span> <span class="pl-s"><span class="pl-pds">'</span>dry-validation<span class="pl-pds">'</span></span>
<span class="pl-k">require</span> <span class="pl-s"><span class="pl-pds">'</span>dry/validation/schema/form<span class="pl-pds">'</span></span>

<span class="pl-k">class</span> <span class="pl-en">UserFormSchema<span class="pl-e"> &lt; Dry::Validation::Schema::Form</span></span>
  key(<span class="pl-c1">:email</span>) { |<span class="pl-smi">value</span>| value.str? <span class="pl-k">&amp;</span> value.filled? }

  key(<span class="pl-c1">:age</span>) { |<span class="pl-smi">value</span>| value.int? <span class="pl-k">&amp;</span> value.gt?(<span class="pl-c1">18</span>) }
<span class="pl-k">end</span>

schema <span class="pl-k">=</span> <span class="pl-c1">UserFormSchema</span>.<span class="pl-k">new</span>

errors <span class="pl-k">=</span> schema.messages(<span class="pl-s"><span class="pl-pds">'</span>email<span class="pl-pds">'</span></span> =&gt; <span class="pl-s"><span class="pl-pds">'</span><span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>age<span class="pl-pds">'</span></span> =&gt; <span class="pl-s"><span class="pl-pds">'</span>18<span class="pl-pds">'</span></span>)

puts errors.inspect

<span class="pl-c"># [[:email, ["email must be filled"]], [:age, ["age must be greater than 18 (18 was given)"]]]</span></pre></div>

<p>There are few major differences between how it works here and in <code>ActiveModel</code>:</p>

<ul>
<li>We have type checking as predicates, ie <code>gt?(18)</code> will not be applied if the value
is not an integer</li>
<li>Thus, error messages are provided <em>only for the rules that failed</em>
</li>
<li>There's a planned feature for generating "validation hints" which lists information
about all possible rules</li>
<li>Coercion is handled by <code>dry-data</code> coercible hash using its <code>form.*</code> types that
are dedicated for this type of coercions</li>
<li>It's very easy to add your own types and coercions (more info/docs coming soon)</li>
</ul>

<h3>
<a id="defining-custom-predicates" class="anchor" href="#defining-custom-predicates" aria-hidden="true"><span class="octicon octicon-link"></span></a>Defining Custom Predicates</h3>

<p>You can simply define predicate methods on your schema object:</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-k">class</span> <span class="pl-en">Schema<span class="pl-e"> &lt; Dry::Validation::Schema</span></span>
  key(<span class="pl-c1">:email</span>) { |<span class="pl-smi">value</span>| value.str? <span class="pl-k">&amp;</span> value.email? }

  <span class="pl-k">def</span> <span class="pl-en">email?</span>(<span class="pl-smi">value</span>)
    <span class="pl-k">!</span> <span class="pl-k">/</span>magical<span class="pl-k">-</span>regex<span class="pl-k">-</span>that<span class="pl-k">-</span>matches<span class="pl-k">-</span>emails<span class="pl-k">/</span>.match(value).nil?
  <span class="pl-k">end</span>
<span class="pl-k">end</span></pre></div>

<p>You can also re-use a predicate container across multiple schemas:</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-k">module</span> <span class="pl-en">MyPredicates</span>
  <span class="pl-k">include</span> <span class="pl-c1">Dry</span>::<span class="pl-c1">Validation</span>::<span class="pl-c1">Predicates</span>

  predicate(<span class="pl-c1">:email?</span>) <span class="pl-k">do </span>|<span class="pl-smi">input</span>|
    <span class="pl-k">!</span> <span class="pl-k">/</span>magical<span class="pl-k">-</span>regex<span class="pl-k">-</span>that<span class="pl-k">-</span>matches<span class="pl-k">-</span>emails<span class="pl-k">/</span>.match(value).nil?
  <span class="pl-k">end</span>
<span class="pl-k">end</span>

<span class="pl-k">class</span> <span class="pl-en">Schema<span class="pl-e"> &lt; Dry::Validation::Schema</span></span>
  configure <span class="pl-k">do </span>|<span class="pl-smi">config</span>|
    config.predicates <span class="pl-k">=</span> <span class="pl-c1">MyPredicates</span>
  <span class="pl-k">end</span>

  key(<span class="pl-c1">:email</span>) { |<span class="pl-smi">value</span>| value.str? <span class="pl-k">&amp;</span> value.email? }
<span class="pl-k">end</span></pre></div>

<p>You need to provide error messages for your custom predicates if you want them
to work with <code>Schem#messages</code> interface.</p>

<p>You can learn how to do that in the <a href="https://github.com/dryrb/dry-validation#error-messages">Error Messages</a> section.</p>

<h2>
<a id="list-of-built-in-predicates" class="anchor" href="#list-of-built-in-predicates" aria-hidden="true"><span class="octicon octicon-link"></span></a>List of Built-In Predicates</h2>

<h3>
<a id="basic-1" class="anchor" href="#basic-1" aria-hidden="true"><span class="octicon octicon-link"></span></a>Basic</h3>

<ul>
<li><code>none?</code></li>
<li><code>eql?</code></li>
<li><code>key?</code></li>
</ul>

<h3>
<a id="types" class="anchor" href="#types" aria-hidden="true"><span class="octicon octicon-link"></span></a>Types</h3>

<ul>
<li><code>str?</code></li>
<li><code>int?</code></li>
<li><code>float?</code></li>
<li><code>decimal?</code></li>
<li><code>bool?</code></li>
<li><code>date?</code></li>
<li><code>date_time?</code></li>
<li><code>time?</code></li>
<li><code>array?</code></li>
<li><code>hash?</code></li>
</ul>

<h3>
<a id="number-string-collection" class="anchor" href="#number-string-collection" aria-hidden="true"><span class="octicon octicon-link"></span></a>Number, String, Collection</h3>

<ul>
<li><code>empty?</code></li>
<li><code>filled?</code></li>
<li><code>gt?</code></li>
<li><code>gteq?</code></li>
<li><code>lt?</code></li>
<li><code>lteq?</code></li>
<li><code>max_size?</code></li>
<li><code>min_size?</code></li>
<li><code>size?</code></li>
<li><code>format?</code></li>
<li><code>inclusion?</code></li>
<li><code>exclusion?</code></li>
</ul>

<h2>
<a id="error-messages" class="anchor" href="#error-messages" aria-hidden="true"><span class="octicon octicon-link"></span></a>Error Messages</h2>

<p>By default <code>dry-validation</code> comes with a set of pre-defined error messages for
every built-in predicate. They are defined in <a href="https://github.com/dryrb/dry-validation/blob/master/config/errors.yml">a yaml file</a>
which is shipped with the gem.</p>

<p>You can provide your own messages and configure your schemas to use it like that:</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-k">class</span> <span class="pl-en">Schema<span class="pl-e"> &lt; Dry::Validation::Schema</span></span>
  configure { |<span class="pl-smi">config</span>| config.messages_file <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">'</span>/path/to/my/errors.yml<span class="pl-pds">'</span></span> }
<span class="pl-k">end</span></pre></div>

<p>You can also provide a namespace per-schema that will be used by default:</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-k">class</span> <span class="pl-en">Schema<span class="pl-e"> &lt; Dry::Validation::Schema</span></span>
  configure { |<span class="pl-smi">config</span>| config.namespace <span class="pl-k">=</span> <span class="pl-c1">:user</span> }
<span class="pl-k">end</span></pre></div>

<p>Lookup rules:</p>

<div class="highlight highlight-source-yaml"><pre><span class="pl-s"><span class="pl-ent">filled?:</span> <span class="pl-s"><span class="pl-pds">"</span>%{name} must be filled<span class="pl-pds">"</span></span></span>

<span class="pl-s"><span class="pl-ent">attributes:</span></span>
  <span class="pl-s"><span class="pl-ent">email:</span></span>
    <span class="pl-s"><span class="pl-ent">filled?:</span> <span class="pl-s"><span class="pl-pds">"</span>the email is missing<span class="pl-pds">"</span></span></span>

<span class="pl-s"><span class="pl-ent">user:</span></span>
  <span class="pl-s"><span class="pl-ent">filled?:</span> <span class="pl-s"><span class="pl-pds">"</span>%{name} name cannot be blank<span class="pl-pds">"</span></span></span>

  <span class="pl-s"><span class="pl-ent">attributes:</span></span>
    <span class="pl-s"><span class="pl-ent">address:</span></span>
      <span class="pl-s"><span class="pl-ent">filled?:</span> <span class="pl-s"><span class="pl-pds">"</span>You gotta tell us where you live<span class="pl-pds">"</span></span></span></pre></div>

<p>Given the yaml file above, messages lookup works as follows:</p>

<div class="highlight highlight-source-ruby"><pre>messages <span class="pl-k">=</span> <span class="pl-c1">Dry</span>::<span class="pl-c1">Validation</span>::<span class="pl-c1">Messages</span>.load(<span class="pl-s"><span class="pl-pds">'</span>/path/to/our/errors.yml<span class="pl-pds">'</span></span>)

messages.lookup(<span class="pl-c1">:filled?</span>, <span class="pl-c1">:age</span>) <span class="pl-c"># =&gt; "age must be filled"</span>
messages.lookup(<span class="pl-c1">:filled?</span>, <span class="pl-c1">:address</span>) <span class="pl-c"># =&gt; "address must be filled"</span>
messages.lookup(<span class="pl-c1">:filled?</span>, <span class="pl-c1">:email</span>) <span class="pl-c"># =&gt; "the email is missing"</span>

<span class="pl-c"># with namespaced messages</span>
user_messages <span class="pl-k">=</span> messages.namespaced(<span class="pl-c1">:user</span>)

user_messages.lookup(<span class="pl-c1">:filled?</span>, <span class="pl-c1">:age</span>) <span class="pl-c"># "age cannot be blank"</span>
user_messages.lookup(<span class="pl-c1">:filled?</span>, <span class="pl-c1">:address</span>) <span class="pl-c"># "You gotta tell us where you live"</span></pre></div>

<p>By configuring <code>messages_file</code> and/or <code>namespace</code> in a schema, default messages
are going to be automatically merged with your overrides and/or namespaced.</p>

<h2>
<a id="i18n-integration" class="anchor" href="#i18n-integration" aria-hidden="true"><span class="octicon octicon-link"></span></a>I18n Integration</h2>

<p>Coming (very) soon...</p>

<h2>
<a id="rule-ast" class="anchor" href="#rule-ast" aria-hidden="true"><span class="octicon octicon-link"></span></a>Rule AST</h2>

<p>Internally, <code>dry-validation</code> uses a simple AST representation of rules and errors
to produce rule objects and error messages. If you would like to programatically
generate rules, it is a very simple process:</p>

<div class="highlight highlight-source-ruby"><pre>ast <span class="pl-k">=</span> [
  [
    <span class="pl-c1">:and</span>,
    [
      [<span class="pl-c1">:key</span>, [<span class="pl-c1">:age</span>, [<span class="pl-c1">:predicate</span>, [<span class="pl-c1">:key?</span>, []]]]],
      [
        <span class="pl-c1">:and</span>,
        [
          [<span class="pl-c1">:val</span>, [<span class="pl-c1">:age</span>, [<span class="pl-c1">:predicate</span>, [<span class="pl-c1">:filled?</span>, []]]]],
          [<span class="pl-c1">:val</span>, [<span class="pl-c1">:age</span>, [<span class="pl-c1">:predicate</span>, [<span class="pl-c1">:gt?</span>, [<span class="pl-c1">18</span>]]]]]
        ]
      ]
    ]
  ]
]

compiler <span class="pl-k">=</span> <span class="pl-c1">Dry</span>::<span class="pl-c1">Validation</span>::<span class="pl-c1">RuleCompiler</span>.<span class="pl-k">new</span>(<span class="pl-c1">Dry</span>::<span class="pl-c1">Validation</span>::<span class="pl-c1">Predicates</span>)

<span class="pl-c"># compile an array of rule objects</span>
rules <span class="pl-k">=</span> compiler.call(ast)

puts rules.inspect
<span class="pl-c"># [</span>
<span class="pl-c">#   #&lt;Dry::Validation::Rule::Conjunction</span>
<span class="pl-c">#     left=#&lt;Dry::Validation::Rule::Key name=:age predicate=#&lt;Dry::Validation::Predicate id=:key?&gt;&gt;</span>
<span class="pl-c">#     right=#&lt;Dry::Validation::Rule::Conjunction</span>
<span class="pl-c">#       left=#&lt;Dry::Validation::Rule::Value name=:age predicate=#&lt;Dry::Validation::Predicate id=:filled?&gt;&gt;</span>
<span class="pl-c">#       right=#&lt;Dry::Validation::Rule::Value name=:age predicate=#&lt;Dry::Validation::Predicate id=:gt?&gt;&gt;&gt;&gt;</span>
<span class="pl-c"># ]</span>

<span class="pl-c"># dump it back to ast</span>
puts rules.map(<span class="pl-k">&amp;</span><span class="pl-c1">:to_ary</span>).inspect
<span class="pl-c"># [[:and, [:key, [:age, [:predicate, [:key?, [:age]]]]], [[:and, [:val, [:age, [:predicate, [:filled?, []]]]], [[:val, [:age, [:predicate, [:gt?, [18]]]]]]]]]]</span></pre></div>

<p>Complete docs for the AST format are coming soon, for now please refer to
<a href="https://github.com/dryrb/dry-validation/blob/master/spec/unit/rule_compiler_spec.rb">this spec</a>.</p>

<h2>
<a id="status-and-roadmap" class="anchor" href="#status-and-roadmap" aria-hidden="true"><span class="octicon octicon-link"></span></a>Status and Roadmap</h2>

<p>This library is in a very early stage of development but you are encauraged to
try it out and provide feedback.</p>

<p>For planned features check out <a href="https://github.com/dryrb/dry-validation/labels/feature">the issues</a>.</p>

<h2>
<a id="license" class="anchor" href="#license" aria-hidden="true"><span class="octicon octicon-link"></span></a>License</h2>

<p>See <code>LICENSE</code> file.</p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/dryrb/dry-validation">dry-validation</a> is maintained by <a href="https://github.com/dryrb">dryrb</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
